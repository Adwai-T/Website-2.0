<!DOCTYPE html>
<html lang="en">
  <head>
    <title></title>
  </head>
  <body>
    <div id="container">
      <div id="index">
        <ul id="index-list">
          <li class="index-li-h2"><a href="#h2-0">Basic Git commands</a></li>
          <li class="index-li-h2"><a href="#h2-1">Intermediate Git</a></li>
          <li class="index-li-h3"><a href="#h3-0">Perfect Commit</a></li>
          <li class="index-li-h3">
            <a href="#h3-1">Change tracking for a file</a>
          </li>
          <li class="index-li-h4">
            <a href="#h4-0">Temprorily untrack files</a>
          </li>
          <li class="index-li-h3"><a href="#h3-2">Branching Strategies</a></li>
          <li class="index-li-h4"><a href="#h4-1">Working with Branches</a></li>
          <li class="index-li-h3">
            <a href="#h3-3">Difference between Fetch and Pull</a>
          </li>
          <li class="index-li-h3"><a href="#h3-4">Pull Requests</a></li>
          <li class="index-li-h3"><a href="#h3-5">Merge Conflicts</a></li>
          <li class="index-li-h3"><a href="#h3-6">Merge vs Rebase</a></li>
          <li class="index-li-h2"><a href="#h2-2">Github</a></li>
          <li class="index-li-h3">
            <a href="#h3-7">Branch Protection Rule</a>
          </li>
        </ul>
      </div>

      <div id="content">
        <h1 id="h1-0">Git and Github</h1>
        <h2 id="h2-0">Basic Git commands</h2>
        <p>
          Check if git is intalled and if installed what version of git is
          installed.
        </p>
        <p><samp>git --version</samp></p>

        <p>
          Configure git after installation : To collaborate we need to identify
          by adding a username and email id. We do that by using
        </p>
        <p><samp>git config --global user.name "Jeff Delaney"</samp></p>
        <p><samp>git config --global user.email "hello@fireship.io"</samp></p>

        <p>
          If we have an identity already added to the configuration we can check
          it by using following which will show us our config.
        </p>
        <p><samp>git config --list</samp>.</p>

        <ul>
          <li><samp>git init</samp></li>
          <li><samp>git status</samp></li>
          <li>
            <samp>git add filename</samp> or <samp>git add .</samp> : to add All
            files
          </li>
          <li>
            <samp>git reset .</samp> or <samp>git rm filename</samp> : to remove
            files from staging area.
          </li>
          <li>
            <samp>git commit -m "message"</samp> : -m is for adding message for
            the commit
          </li>
          <li>
            <samp>git commit -am "message"</samp> : -a adds all the tracked file
            and hence can skip the <samp>git add</samp> if no new files have to
            be added to tracked files.
          </li>
          <li><samp>git log</samp> : see history of all commits.</li>
          <li>
            <samp>git remote</samp> : Check all the remote repositories set for
            your project. For example if you deploy a project that might be a
            remote(like heroku) and the other can be github.
          </li>
          <li>
            <samp>git remote -v</samp> : Get detail links about all remotes.
          </li>
          <li>
            <samp>git remote rename currentName toName</samp> : Change the
            current name of remote.
          </li>
          <li>
            <samp>git push</samp> : will push to the default repo and the main
            branch.
          </li>
          <li>
            <samp>git push origin master</samp> : push to the origin remote repo
            and its main/master branch.
          </li>
          <li>
            <samp>git push --set-upstream remoteName branchName</samp> : push
            the current branch and set the remote as upstream use.
          </li>
          <li>
            <samp>git fetch</samp> : fetch updated code from remote repositroy.
            It need to be used with
            <samp>git branch, git checkout and git reset</samp>.
          </li>
          <li>
            <samp>git merge branchName</samp> : merge code with remote repo.
          </li>
          <li>
            <samp>git pull</samp> : is a Git command used to update the local
            version of a repository from a remote
          </li>
          <li>
            <samp>git clone &lt;repo-url&gt; &lt;local-directory&gt;</samp> :
            clone a remote repo to local directory and optionally change name.
          </li>
        </ul>
        <p>Branches in git :</p>

        <ul>
          <li><samp>git branch</samp> : list of all branches.</li>
          <li><samp>git branch branchname</samp> : create a new branch.</li>
          <li><samp>git checkout brachname</samp> : move into a branch.</li>
          <li>
            <samp>git checkout -b branchname</samp> : create and move into a
            branch.
          </li>
          <li>
            <samp>git switch -c branchname</samp> : from git 2.23 can be used to
            create and move into branch. <samp>-c</samp> is
            <samp>--create</samp>.
          </li>
          <li><samp>git branch -v</samp> : show last commit on each branch.</li>
          <li>
            <samp>git log --oneline --decorate</samp> : decorated view of
            branches and commits
          </li>
          <li>
            <samp>git log branchName</samp> : show commits for that branch
          </li>
          <li><samp>git log --all</samp> : show all branches and commits</li>
          <li><samp>git branch -d branchname</samp> : delete a branch.</li>
          <li>
            <samp>git branch --merged</samp> : branches that are already merged
            into the currently active branch.
          </li>
          <li>
            <samp>git branch --no-merged</samp> : branches not already merged
            with curretly active branch.
          </li>
        </ul>
        <quote>
          Do not rename branches that are still in use by other
          collaborators.</quote
        >
        <p>Changes to Commits</p>

        <ul>
          <li>
            <samp>git reset &lt;commit-ID&gt;</samp> Rollback to a previous
            commit but keep the changes in the working directory.
          </li>
          <li>
            <samp>git reset &lt;commit-ID&gt; --hard</samp> : Rollback to
            previous commit and discard all changes.
          </li>
          <li>
            <samp>git revert &lt;commit-ID&gt; -m "reverting last commit"</samp>
            : Undo a commit with a new commit.
          </li>
          <li>
            <samp>git commit --amend -m "better message"</samp> : Update the
            message of previous commit
          </li>
          <li>
            <samp>git add &lt;your-file&gt;</samp> then
            <samp>git commit --amend --no-edit</samp> to add a file that we
            forgot to add in the previous commit.
          </li>
          <li>
            <samp>git log --graph --oneline --decorate</samp> to look at all the
            commits and branches in a nicer way.
          </li>
        </ul>
        <p>
          <strong>Git stach</strong> : When we have code that is work in
          progress and we dont want to commit it yet we can store it in a stash
          . Git stash Remove the changes that are not commited from the current
          working directory and save them for later use.
        </p>

        <ul>
          <li>
            <samp>git stash</samp> : This will create a stash of current
            changes.
          </li>
          <li>
            <samp>git pop</samp> : Add back the changes to current working
            directory.
          </li>
          <li>
            <samp>git stach save stash-name</samp> : If we want to use multiple
            stashes we can name the stash and then add particular stash to
            working directory as needed.
          </li>
          <li><samp>git stash list</samp> : list of all stash with id.</li>
          <li>
            <samp>git stash apply stash-id</samp> : to add the stash to working
            directory.
          </li>
          <li><samp>git stash drop stash-id</samp> : delete stash.</li>
        </ul>
        <p>
          Reset code from remote Repo: Lets say we have a remote repo and a
          local repo and thing are not working on the local repo after some
          changes were made and we want the code to be reset to the state on the
          remote repo.
        </p>

        <ul>
          <li>
            <samp>git fetch origin</samp> : first step fetch code from remote
            repo.
          </li>
          <li>
            <samp>git reset --hard origin/master</samp> : Then we override the
            local code with remote code. Note that the local changes will be
            lost forever.
          </li>
          <li>
            <samp>git clean -df</samp> : This will remove all the untracked
            files form the local repository.
          </li>
        </ul>
        <ul>
          <li>
            <samp>git update-git-for-windows</samp> : Update to the lates
            version of git from windows when git is already installed.
          </li>
        </ul>
        <p>Following two steps can be used to reset to the last commit.</p>

        <ul>
          <li>
            git reset HEAD --hard : This will undo any changes you've made to
            tracked files and restore deleted files.
          </li>
          <li>
            git clean -fd : This will delete any new files that were added since
            the last commit. Files that are not tracked due to .gitignore are
            preserved; they will not be removed. The <samp>f</samp> is for files
            and <samp>d</samp> is for directories. Using <samp>x</samp> will
            also delete untracked files, it is not recommended to do it as most
            times we would not want to do that.
          </li>
        </ul>
        <h2 id="h2-1">Intermediate Git</h2>
        <h3 id="h3-0">Perfect Commit</h3>
        <p>
          Separate topics while we commit. In the staging area we can add
          selected files or even parts of files.
        </p>

        <p>
          We can add parts of the changes done to a file if not all changes made
          to a given file are for the same topic/concern. We use
          <samp>git add -p filename.js</samp>. The <samp>-p</samp> flag is used
          in the case. Now git will take us through the file and we can then
          command git to add or not to add the part of file with
          <samp>y | n</samp>.
        </p>

        <p>
          If we add a part of file the file name will be seen both in staged and
          non staged files list.
        </p>

        <p>
          To quickly commit we might add a commit message directly with out
          commit using the flag <samp>-m</samp> but we want to add a commit
          message heading as well as describe the commit details in a commit
          body.
        </p>

        <p>
          When we use <samp>git commit</samp> once we have staged the files for
          the commit, it will open out editor and we can write our message
          heading over there. Then if we add an empty line after the subject we
          can then add a desciption for the commit. Here we importantly want to
          add the change but also if there is anything that needs to be watched
          for in the commit.
        </p>

        <h3 id="h3-1">Change tracking for a file</h3>
        <p>
          A file that is already been added to be tracked by git cannot be
          untracked just by later adding it to git ignore.
        </p>

        <p>
          We need to untrack the file before we add the rule to
          <samp>.gitignore</samp>.
        </p>

        <p>To do that we use <samp>git rm --cached FileName</samp>.</p>

        <p>
          When we want to untrack a whole directory we will use the
          <samp>-r</samp> flag for recursive ignore.
        </p>

        <p><samp>git rm -r --cached &lt;file&gt;</samp></p>

        <h4 id="h4-0">Temprorily untrack files</h4>
        <p>
          git
          <a
            href="https://mirrors.edge.kernel.org/pub/software/scm/git/docs/git-update-index.html"
            target="_blank"
            >update-index</a
          >.
        </p>

        <p>
          Consider we don't want to track file for some commits. We can set that
          file to be <samp>--assume-unchanged</samp> so git will not track the
          changes to that file in the next commits until we set the file to be
          tracked for changes again <samp>--no-assume-unchanged</samp>.
        </p>

        <p><samp>git update-index --assume-unchanged path/to/file</samp></p>

        <p><samp>git update-index --no-assume-unchanged path/to/file</samp></p>

        <h3 id="h3-2">Branching Strategies</h3>
        <p>
          WE can have different branches for features or development and a main
          branch.
        </p>

        <p>
          The branches can also be classifed as Long Running and Short-Lived
          branches.
        </p>

        <p>
          Every project has alteast one Long Running branch, called master or
          main.
        </p>

        <p>
          Short_Lived branches are created for a purpose and are reintegrated
          into a Long Running branch once that purpose is fulfilled. And then
          the branch can be deleted.
        </p>

        <p>There are two types how git branching strategy can be used.</p>

        <ul>
          <li>
            GitHub Flow : it is a very simple, very lean, only one long -running
            branch("main") + feature branches.
          </li>
        </ul>
        <ul>
          <li>
            GitFlow : This might offer more structure but also needs to follow a
            lot more rules.
          </li>
        </ul>
        <h4 id="h4-1">Working with Branches</h4>
        <p>
          The default branch name for a new git repository is
          <samp>master</samp>. As commits are made, we are give a master branch
          that points to the last commit made.
        </p>

        <p>
          When further commits are made the master branch pointer moves forward
          automatically.
        </p>

        <p>
          The <strong>master</strong> branch in Git is not a special branch. It
          is exactly like any other branch. The only reason nearly every
          repository has one is that the git init command creates it by default
          and most people don’t bother to change it.
        </p>

        <p>
          When a new branch is created, git gives us a new pointer to move
          around. The new pointer when created points to the same commit as the
          currently active branch.
        </p>

        <p>
          <strong>HEAD</strong> is a special pointer that is used by git to keep
          track of the currently active branch. It is the pointer to the local
          branch that we are currently on.
        </p>

        <p>
          When we <samp>git checkout branchName</samp> the
          <samp>HEAD</samp> pointer moves to that branch and git reverts the
          file in the working directory back to the snapshot that the branch
          points to.
        </p>

        <quote>
          If while switching to another branch there are conflicting files in
          the working directory or staging area, git will not allow switching
          branches. We can either stash changes or commit ammend to get around
          this.</quote
        >
        <p>
          This means, the changes made to the branch here on forward will
          diverge from the older version of the project. Essentailly changes
          made to the branches are now isolated from each other.
        </p>

        <quote>
          Run <samp>git log --oneline --decorate --graph --all</samp> to print
          the history of all the commits, showing where the branches point and
          how branches have diverged.</quote
        >
        <p>
          Branches can be merged when we have completed work on them. Say for
          example we merge <em>development</em> branch with the <em>master</em>.
          Now both the pointer will point to the same commit. We can then delete
          the <em>development</em> branch. If we keep the
          <em>development</em> branch and commit to <em>master</em> branch, the
          master pointer will move forward but the development header will still
          remain on the same commit. If we continue working on the
          <em>master</em> branch and make several commits, we can then merge the
          master branch with <em>development</em> branch so they are both
          pointing to the same commit.
        </p>

        <p>
          In case of complex tree Git will use the common ancestor and a method
          called three way merge to merge the two branches and will create a new
          commit. This is called as a <strong>merge commit</strong> and is
          special in that it has more than one parent.
        </p>

        <p>
          Occasionally, this process doesn't go smoothly. If we changed the same
          part of the same file differently in the two branches we're merging,
          Git won't be able to merge them cleanly. See Merge Conflicts below or
          refer to the below official links.
        </p>

        <quote>
          Remote repository linked with the project also have their own pointer
          that point to the state of commit on the remote server repository.
          They cannot be controlled manually and are automatically updated by
          git as we update our remote repository when pushed.</quote
        >
        <p>Git Official Resources.</p>

        <p>
          <a
            href="https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell"
            target="_blank"
            >Working with branches</a
          >.
        </p>

        <p>
          <a
            href="https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging"
            target="_blank"
            >Basic Branching and Merging</a
          >.
        </p>

        <p>
          <a
            href="https://git-scm.com/book/en/v2/Git-Tools-Advanced-Merging#_advanced_merging"
            target="_blank"
            >Advanced Merging</a
          >.
        </p>

        <h3 id="h3-3">Difference between Fetch and Pull</h3>
        <p>
          While the <samp>git fetch</samp> command will fetch all the changes on
          the server that we don't have yet, it will not modify our working
          directory at all. It will simply get the data for us and let us merge
          it ourselves.
        </p>

        <p>
          However, <samp>git pull</samp> which is essentially a
          <samp>git fetch</samp> immediately followed by a
          <samp>git merge</samp> in most cases.
        </p>

        <p>
          Generally it's better to simply use the fetch and merge commands
          explicitly as the magic of <samp>git pull</samp> can often be
          confusing.
        </p>

        <h3 id="h3-4">Pull Requests</h3>
        <p>
          We first create a fork of the repo we would like to contribute to. The
          Fork maintains a link to the upstream repo so we can pull in future
          changes from the original repo. Then we clone the forked repo into our
          local computer.
        </p>

        <p>
          Once we have the project in our local computer we create new branch,
          and then move into the branch. We can then make changes to the branch
          and commit to it. Then we can push the changes to the remote fork by
          using <samp>git push origin branchname</samp>.
        </p>

        <p>
          Is used to communicate about and reveiew our code. WE can also use it
          for contributing code to other repositories that we don't have
          permissions to.
        </p>

        <p>
          We can fork the project that we want to contirbute to, then make the
          changes and make a pull request to the creator of the project to merge
          your changes to the original project.
        </p>

        <p>
          Pull Requests are not a core feature of git, but is provided by our
          remote git repository and hence they might look a little different on
          different hosts like github or gitlab etc.
        </p>

        <h3 id="h3-5">Merge Conflicts</h3>
        <p>
          Lets say we wanted to merge develop branch with the main branch. We
          will use <samp>git merge branch-name</samp>.
        </p>

        <p>
          When a conflict has occured we can use <samp>git diff</samp> to check
          the conflict.
        </p>

        <p>
          WE can undo a conflict and start over by using
          <samp>git merge --abort</samp> and <samp>git rebase --abort</samp> for
          respective merge or rebase conflicts.
        </p>

        <p>
          Solving Conflict can be as simple as cleaning up the file. It can be
          done by using a GUI or manually by editing the file so that the
          conflict is resolved.
        </p>

        <p>
          We can resolve conflict manually by editing the conflict file on the
          master branch and then creating a merge commit/ or simply a new commit
          on main branch.
        </p>

        <p>
          GUI can help in conflict resolve and make it much faster and clear.
        </p>

        <h3 id="h3-6">Merge vs Rebase</h3>
        <p>
          When <strong>merge</strong> is done git looks at atleast three
          commits, the ancestor commit(the commit that the branches share), the
          last commit on the branch being merged and the last commit on the
          branch in which child branch will be merged.
        </p>

        <p>
          If there are multiple commits on the main branch git will have to
          create a commit to merge the branches also called as a merge commit.
        </p>

        <p>
          Rebase is used to remove branch history and convert the branched
          structure into a single branch, mostly the main branch.
        </p>

        <p>
          We have to consider that rebase will rewrite the last commit and also
          change the parent of the last commit, this might not be good if the
          code is already pushed to a remote repository that might be used by
          other developers on other projects as the parent of the last commit is
          changed which effectively makes it a different, distinct commit.
        </p>

        <p>
          We ideally want to use rebase for our local repository before it is
          pushed onto a remote/shared repository
        </p>

        <p>
          We use <samp>git rebase branch-name</samp> to rebase a branch into
          main.
        </p>

        <p>
          <samp>git rebase master --interactive</samp> Start an interactive
          rebase from a feature, then choose the squash commend to flatten your
          commits into a single message.
        </p>

        <quote>
          Git merge preserves the branch history where as git rebase will club
          the branches together into one branch as if the development was done
          on a single branch.</quote
        >
        <h2 id="h2-2">Github</h2>
        <quote>
          When on github on a project page press <samp>&gt;</samp> to open the
          project on browser based vs code.</quote
        >
        <h3 id="h3-7">Branch Protection Rule</h3>
        <p>
          If there are multiple moderators/maintainers for a github repository,
          there is a need for rules on which is the main branch, who can make
          changes to the main branch(like merge other branches), or need
          approval to merge to main branch etc.
        </p>

        <p>These rules are controlled in this section.</p>
      </div>
    </div>
    <!-- Format -->
    <script src="../../highlight/highlight.min.js"></script>
    <script src="../../library/format.js"></script>
  </body>
</html>
